## 关于构造的设计模式 Creation

- Factory 工厂模式

  - 总是能通过输入参数类型的不同，返回固定类型的程序构建结果，用户无需了解内部的运作模式
    这种模式一般会使用 if 语句来进行判别。
  - 例：
    通过椅子工厂类生产一把椅子，用户只需要输入 大、中、小 规格 ， 程序就会构造一把椅子返回，并且每次同类型的返回结果都是的一致的。

---

- Abstract Factory 抽象工厂模式
  - 围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。可以视为一系列工厂的集合，用户可以选择工厂及对应的产品，用户无需了解内部的运作模式
    这种模式一般会使用 if 语句来进行判别。
  - 例：
    通过家居工厂类生产家具，家具工厂含有两个工厂类：椅子类和桌子类，用户可以选择构建任意的家具 [e.g. 椅子-大, 桌子-小]。

---

- Builder 建造者模式
  - 构建复杂对象的一种方式，注重过程的分离，构建器 Builder 高度自定义，构建者可以自行增减部件、随意调换构建顺序，参数也可设定为可选的有默认值的。
  - Director 执行者，决定了如何操作 Builder 以生产合适的对象，可以有多个 Director。
  - 使用链式调用会让整个构建器更加灵活 比如 new Builder().buildA().buildB().buildC().output()
  - 例子见 [builder](./Creational/builder)

---

- Prototype 原型模式
  - 类实现 clone 方法 -> 提供 deepClone 和 shallowClone 两种 mode
  - 个人理解: 创建大量对象时为节省资源而实现的一种设计模式(如携带静态数据,或不可变数据)
    在节省资源的情况下使用 shallowClone (e.g. Object.assign())
    注意如果不希望改变原有的示例, 应该避免对内部的引用类型数据做修改
  - 使用较少

---

- Singleton 单例模式
  - 保证只有一个示例运行的设计模式，实际中会经常被使用
  - 使用函数创建闭包即是一种单例模式 (函数式)
  - 例子见 [singleton](./Creational/singleton)

---

---

## 关于结构的设计模式 Structural

- Decorator 装饰器模式

  - OOP FP 均可适用
  - 相当于一层 wrapper 改变原有的方法，而不修改原有的方法
  - 在设计模式层面上, 装饰器是可以递归嵌套使用的(同一个装饰器也可以多次嵌套)
  - 例子见 [decorator](./Structual/decorator)

---

- Adaptor 适配器模式

  - 与装饰器模式有点类似
  - 几项实现要素
    - 两个或多个接口/类的方法名称, 参数, 处理方式等不同
    - 希望兼容某一种类 使得他们可以执行一样的方法
    - 适配器
      - 传入希望兼容的某个类
      - 实现被兼容类的方法
        (如果希望 ClassB 适配 ClassA 则需要添加一个适配器, 构建适配器 B -> 兼容 A)
  - 调用时的效果:
    兼容类-> new 适配器(兼容类) -> 被兼容类
  - 例子见 [adapter](./Structual/adapter)

---

- Facade 外观模式

  - 为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这一接口使得对子系统的使用更加方便
  - 场景:
    - 当需要为一个复杂子系统提供一个简单的接口时。
    - 当客户端的代码需要和抽象的实现进行解耦时
    - 当需要建立一个有层次的子系统时，子系统之间的通信可以仅仅通过 facade 进行，大大降低耦合。
  - 例子见 [facade](./Structual/facade)

---

- Bridge 桥接模式

  - 桥接模式通过将继承改为组合的方式来解决这个问题。
  - 例:
    有一个 Shape 类实现 draw 的 方法绘制图形
    如果只在 Shape 类扩充绘制方法, 这个类会变得越来越复杂
    使用桥接模式设计, 我们可以独立出实现 Shape 类基本方法的子类
    这时候, 使用场景从:
    new Shape.其他图形.其他方法 ...
    变为:
    new 其他图形(Shape).其他方法

  - 桥接模式是对代码直接重构, 而适配器模式是在外部适配
  - typescript 的抽象类, 其实比较类似

---

- Flyweight 享元模式

  - 一种缓存机制?

---

- Composite 组合模式

  - 产生一种树形的结构, 表示不同对象的相互关系
  - 常见的结构关系: 文件系统 / html 标签 / xml / ...其他一切可嵌套的结构体

---

- Proxy 代理模式

  - 通过跟踪源对象的变化而提供额外功能的一种方式
  - 例子如: ES6 Proxy / Axios interceptor / Vue bind

---

---

## 关于行为的设计模式 Behavioral

- Command 命令模式

  - 三个角色 调用者(Invoker) Command(命令) Receiver(接收者)
  - Receiver 所有命令的载体
  - Command <- 使用特定的 Command 类创建, Command 的动作来源: Receiver, 实现执行 execute 命令
  - Invoker 使用命令前进行 注册 register(Command) 后, 可以执行 execute 命令

  - 这个模式下 可以实现命令历史 撤回/重做
  - 例子见 [command](./Behavioral/command)

- Chain of Responsibility 责任链模式

  - 对象/载荷会在管道中传递 直至被处理完全
  - 对象/载荷对管道的处理次数和被谁处理是完全未知的
  - 链的传递顺序可以是随机的, 也可以是硬编码固定(这样经常会有更高的效率)
  - 每个处理器/继承器(Successor) 实现通用的接口, 他们可以独立工作, 被任意顺序/递归调用
  - express, koa 就是使用这个模式的典型
  - 应用场景:
    - 金融/餐饮行业 找零机(实现纸币数最少)
    - 问答机器人
  - 例子见 [ATM 找零机](./Behavioral/chain-of-responsibility/example/)

- Observer 观察者模式
  - 也可以叫发布/订阅模式
  - 一种典型的程序设计模式
  - 对象的修改需要传递到其他对象, 且依赖数未知
  - 一个目标对象 (Subject) 被多个观测者(Observer)观测, 被观测对象无需了解观测者内部
    的组成, 只是使用自身的消息发布方法对所以订阅者发布消息
  - 主流的现代前端框架: React / Vue 遵循这一规则
  - 例子 [MVC]
