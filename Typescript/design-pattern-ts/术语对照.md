## 关于构造的设计模式 Creation

### Factory 工厂模式

- 总是能通过输入参数类型的不同，返回固定类型的程序构建结果，用户无需了解内部的运作模式
  这种模式一般会使用 if 语句来进行判别。
- 例：
  通过椅子工厂类生产一把椅子，用户只需要输入 大、中、小 规格 ， 程序就会构造一把椅子返回，并且每次同类型的返回结果都是的一致的。

---

### Abstract Factory 抽象工厂模式

- 围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。可以视为一系列工厂的集合，用户可以选择工厂及对应的产品，用户无需了解内部的运作模式
  这种模式一般会使用 if 语句来进行判别。
- 例：
  通过家居工厂类生产家具，家具工厂含有两个工厂类：椅子类和桌子类，用户可以选择构建任意的家具 [e.g. 椅子-大, 桌子-小]。

---

### Builder 建造者模式

- 构建复杂对象的一种方式，注重过程的分离，构建器 `Builder` 高度自定义，构建者可以自行增减部件、随意调换构建顺序，参数也可设定为可选的有默认值的。
- `Director` 执行者，决定了如何操作 `Builder` 以生产合适的对象，可以有多个 `Director。`
- 使用链式调用会让整个构建器更加灵活 比如 `new Builder().buildA().buildB().buildC().output()`
- 例子见 [builder](./Creational/builder)

---

### Prototype 原型模式

- 类实现 clone 方法 -> 提供 deepClone 和 shallowClone 两种 mode
- 个人理解: 创建大量对象时为节省资源而实现的一种设计模式(如携带静态数据,或不可变数据)
  在节省资源的情况下使用 shallowClone (e.g. Object.assign())
  注意如果不希望改变原有的示例, 应该避免对内部的引用类型数据做修改
- 使用较少

---

### Singleton 单例模式

- 保证只有一个示例运行的设计模式，实际中会经常被使用
- 使用函数创建闭包即是一种单例模式 (函数式)
- 例子见 [singleton](./Creational/singleton)

---

---

## 关于结构的设计模式 Structural

### Decorator 装饰器模式

- OOP FP 均可适用
- 相当于一层 wrapper 改变原有的方法，而不修改原有的方法
- 在设计模式层面上, 装饰器是可以递归嵌套使用的(同一个装饰器也可以多次嵌套)
- 例子见 [decorator](./Structual/decorator)

---

### Adaptor 适配器模式

- 与装饰器模式有点类似
- 几项实现要素
  - 两个或多个接口/类的方法名称, 参数, 处理方式等不同
  - 希望兼容某一种类 使得他们可以执行一样的方法
  - 适配器
    - 传入希望兼容的某个类
    - 实现被兼容类的方法例如:
      希望 `ClassB` 适配 `ClassA` 则需要添加一个适配器, 构建 `适配器 ClassB` -> `兼容 ClassA`
- 调用时的效果:
  `兼容类`-> `new 适配器(兼容类)` -> `被兼容类`
- 例子见 [adapter](./Structual/adapter)

---

### Facade 外观模式

- 为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这一接口使得对子系统的使用更加方便
- 场景:
  - 当需要为一个复杂子系统提供一个简单的接口时。
  - 当客户端的代码需要和抽象的实现进行解耦时
  - 当需要建立一个有层次的子系统时，子系统之间的通信可以仅仅通过 facade 进行，大大降低耦合。
- 例子见 [facade](./Structual/facade)

---

### Bridge 桥接模式

- 桥接模式通过将继承改为组合的方式来解决这个问题。
- 例:
  有一个 `Shape` 类实现 `draw` 的方法绘制图形
  如果只在 `Shape` 类扩充绘制方法, 这个类会变得越来越复杂
  使用桥接模式设计, 我们可以独立出实现 `Shape` 类基本方法的子类
  这时候, 使用场景从:
  `new Shape.其他图形.其他方法` ...
  变为:
  `new 其他图形(Shape).其他方法`

- 桥接模式是对代码直接重构, 而适配器模式是在外部适配
- typescript 的抽象类, 其实比较类似

---

### Flyweight 享元模式

- 一种缓存机制?

---

### Composite 组合模式

- 产生一种树形的结构, 表示不同对象的相互关系
- 常见的结构关系: 文件系统 / html 标签 / xml / ...其他一切可嵌套的结构体

---

### Proxy 代理模式

- 通过跟踪源对象的变化而提供额外功能的一种方式
- 例子如: ES6 Proxy / Axios interceptor / Vue bind

---

---

## 关于行为的设计模式 Behavioral

### Command 命令模式

- 三个角色 调用者(`Invoker`) `Command`(命令) `Receiver`(接收者)
- `Receiver` 所有命令的载体
- `Command` <- 使用特定的 `Command` 类创建, `Command` 的动作来源: `Receiver`, 实现执行 `execute` 命令
- `Invoker` 使用命令前进行 注册 register(`Command`) 后, 可以执行 `execute` 命令

- 这个模式下 可以实现命令历史 撤回/重做
- 例子见 [command](./Behavioral/command)

---

### Chain of Responsibility 责任链模式

- 对象/载荷会在管道中传递 直至被处理完全
- 对象/载荷对管道的处理次数和被谁处理是完全未知的
- 链的传递顺序可以是随机的, 也可以是硬编码固定(这样经常会有更高的效率)
- 每个处理器/继承器 `(Successor)` 实现通用的接口, 他们可以独立工作, 被任意顺序/递归调用
- `express`, `koa` 就是使用这个模式的典型
- 应用场景:
  - 金融/餐饮行业 找零机(实现纸币数最少)
  - 问答机器人
- 例子见 [ATM 找零机](./Behavioral/chain-of-responsibility/example/)

---

### Observer 观察者模式

- 也可以叫发布/订阅模式
- 一种典型的程序设计模式
- 对象的修改需要传递到其他对象, 且依赖数未知
- 一个目标对象 `(Subject)` 被多个观测者 `(Observer)` 观测, 被观测对象无需了解观测者内部
  的组成, 只是使用自身的消息发布方法对所以订阅者发布消息
- 主流的现代前端框架: React / Vue 遵循这一规则
- 例子 [MVC 框架](./Behavioral/observer/example/)

---

### Interceptor 解释器模式

- 通常用于构造 AST 抽象语法树
- 使用此模式可以将一种未知的语法模式转换成计算机可以处理的模式
- 是已编码数据和未编码数据的一种集合
  例如: 程序希望实现 `'1 ADD 2'`, 1 2 是可以被理解的纯数字, 而 `ADD` 是一种未编码的语句, 需要对 `ADD` 进行处理以便得出运算结果
- 所有的实例应实现类似 `intercept` 方法以提供运行时的具体解释逻辑(比如, 返回值, 进行运算, 操作对象...)
- 例子 [interceptor calculate](./Behavioral/interceptor)
- 测验: 实现一个罗马数字运算

---

### Iterator 迭代器模式

- 为实现可迭代的聚合体而实现的模式
- 一般编程语言都内置了有迭代器的基本数据类型, 故一般情况下不需要自行实现, 除非有特殊逻辑
- 例子 [Object 迭代器](./Behavioral/iterator)

---

### Mediator 中介模式

- 通过一个中介管理不同对象之间的数据通信交换，以便拓展功能，实现一对多的通信等
- 例子 [EventBus](./Behavioral/mediator)

---

### Memento 备忘录模式

- 通过一个存储/备忘录类 Memento 做数据持久化, Memento 实现与源对象 Originator 中需要持久化 data 一致的接口(该模式不一要求保存所有的数据, 可根据需求自行选择)
- 是否实时在原对象改变时存储状态, 取决于需求而动态调整, 有可能你只是需要手动保存, 或者 10 分钟自动保存一下文档, 亦或是实时记录日志
- 保存状态时注意拷贝类型是 深拷贝/浅拷贝
- 例子 [GameSaver](./Behavioral/memento)

---

### Strategy 策略模式

- 有数个不同的策略类拥有相同的方法, 但实现不一样的处理方式和结果
- 管理策略的类 根据传入的不同策略, 调用方法执行, 返回结果。
- 与之非常相似的设计模式 状态 State 模式 (由于相似度高, 这里没有演示)
  区分它们的方法是考虑上下文的状态是在运行时选择算法(State)，还是将算法传递给它(Strategy)。
- 这种模式的好处是策略可以在**外部**进行增减, 而无需在实现类内修改, 便利性很好(这也是为什么容易作为插件的设计模式)。
- 使用场景: 软件插件 、可供用户选择参数实现不同效果的软件交互等
- 例子 [Different Level of Hotels](./Behavioral/strategy)

---

### Template Method 模板方法模式

- 提供模板类实现一个抽象父类(模板)，内部的方法(或者称为插槽 `SLOT`/钩子 `HOOKS`)是可以选择实现,
  也可以是必须实现的, 选择实现的成员应该有一个默认值
- 模板内部实现最终的效果呈现, 呈现的方法执行顺序应由模板类内部决定而不受外界影响
- 使用场景: 前端使用这一模式非常广泛, 例如:
  - HTML 模板引擎
  - HTML 原生 `<slot>` 插槽标签
  - 主流现代框架 React 的 `props & children` / Vue 的 `props & slot`
- 例子 [Template Abstract](./Behavioral/template)

---

### Visitor 访问者模式

- 使用这种模式, 可实现一种针对**具有层次结构的, 其中元素(`Part`)的**的操作
- 使用这种模式, 无需修改内部的组件 `Part` 类
- 在设计程序时可以通过实现该模式, 预留未来外部访问的能力
- 例子 [Car Information](./Behavioral/visitor)
