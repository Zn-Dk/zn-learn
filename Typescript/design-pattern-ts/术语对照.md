## 关于构造的设计模式 Creation

- Factory 工厂模式

  - 总是能通过输入参数类型的不同，返回固定类型的程序构建结果，用户无需了解内部的运作模式
    这种模式一般会使用 if 语句来进行判别。
  - 例：
    通过椅子工厂类生产一把椅子，用户只需要输入 大、中、小 规格 ， 程序就会构造一把椅子返回，并且每次同类型的返回结果都是的一致的。

---

- Abstract Factory 抽象工厂模式
  - 围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。可以视为一系列工厂的集合，用户可以选择工厂及对应的产品，用户无需了解内部的运作模式
    这种模式一般会使用 if 语句来进行判别。
  - 例：
    通过家居工厂类生产家具，家具工厂含有两个工厂类：椅子类和桌子类，用户可以选择构建任意的家具 [e.g. 椅子-大, 桌子-小]。

---

- Builder 建造者模式
  - 构建复杂对象的一种方式，注重过程的分离，构建器 Builder 高度自定义，构建者可以自行增减部件、随意调换构建顺序，参数也可设定为可选的有默认值的。
  - Director 执行者，决定了如何操作 Builder 以生产合适的对象，可以有多个 Director。
  - 使用链式调用会让整个构建器更加灵活 比如 new Builder().buildA().buildB().buildC().output()
  - 例子见 [builder](./Creational/builder)

---

- Prototype 原型模式
  - 类实现 clone 方法 -> 提供 deepClone 和 shallowClone 两种 mode
  - 个人理解: 创建大量对象时为节省资源而实现的一种设计模式(如携带静态数据,或不可变数据)
    在节省资源的情况下使用 shallowClone (e.g. Object.assign())
    注意如果不希望改变原有的示例, 应该避免对内部的引用类型数据做修改
  - 使用较少

---

- Singleton 单例模式
  - 保证只有一个示例运行的设计模式，实际中会经常被使用
  - 使用函数创建闭包即是一种单例模式 (函数式)
  - 例子见 [singleton](./Creational/singleton)

## 关于结构的设计模式 Structural

- Decorator 装饰器模式
  - OOP FP 均可适用
  - 相当于一层 wrapper 改变原有的方法，而不修改原有的方法
  - 在设计模式层面上, 装饰器是可以递归嵌套使用的(同一个装饰器也可以多次嵌套)
  - 例子见 [decorator](./Structual/decorator)

---

- Adaptor 适配器模式
  - 与装饰器模式有点类似
  - 几项实现要素
    - 两个或多个接口/类的方法名称, 参数, 处理方式等不同
    - 希望兼容某一种类 使得他们可以执行一样的方法
    - 适配器
      - 传入希望兼容的某个类
      - 实现被兼容类的方法
        (如果希望 ClassB 适配 ClassA 则需要添加一个适配器, 构建适配器 B -> 兼容 A)
  - 调用时的效果:
    兼容类-> new 适配器(兼容类) -> 被兼容类
  - 例子见 [adapter](./Structual/adapter)
