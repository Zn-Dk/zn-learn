# Shell 命令的输出,执行状态和比较运算

## 常见命令解释

### if [ $? -eq 0 ];then 是什么意思?

- 在 shell 脚本中，表示 **$?** 代表上一个命令执行后的退出状态；
- **`-eq`**：表示等于；
- 语句`if [ $? -eq 0 ]`表示 shell 传递到脚本的参数等于0，则执行 then 中的语句。



### 输出到黑洞  \>/dev/null 2>&1 是什么意思?

当执行shell命令时，会默认打开3个文件，每个文件有对应的文件描述符来方便我们使用：



| 类型                        | 文件描述符 | 默认情况               | 对应文件句柄位置 |
| :-------------------------- | :--------- | :--------------------- | :--------------- |
| 标准输入（standard input）  | 0          | 从键盘获得输入         | /proc/self/fd/0  |
| 标准输出（standard output） | 1          | 输出到屏幕（即控制台） | /proc/self/fd/1  |
| 错误输出（error output）    | 2          | 输出到屏幕（即控制台） | /proc/self/fd/2  |

![9cdc4e1e1ff1812f111ddb17c05d0e18f8406bb1.png@942w_480h_progressive](assets\9cdc4e1e1ff1812f111ddb17c05d0e18f8406bb1.png@942w_480h_progressive.webp)



- **>/dev/null**

这条命令的作用是将标准输出1重定向到`/dev/null`中。 `/dev/null`代表linux的空设备文件，所有往这个文件里面写入的内容都会丢失，俗称“黑洞”。那么执行了`>/dev/null`之后，标准输出就会不再存在，没有任何地方能够找到输出的内容。

![35c1e6e9a452a936d2e3e18b4a802afa2fe64665.png@942w_350h_progressive](assets\35c1e6e9a452a936d2e3e18b4a802afa2fe64665.png@942w_350h_progressive.webp)

- **2>/dev/null**

![img](assets\8da76e42d70e02c804f488baa0f25be3e1085793.png@942w_267h_progressive.webp)

- **2>&1**

这条命令用到了重定向绑定，采用&可以将两个输出绑定在一起。这条命令的作用是错误输出将和标准输出同用一个文件描述符，说人话就是错误输出将会和标准输出输出到同一个地方。![img](assets\16f923a4b4529825f238f8ce9f52652287a99568.png@942w_251h_progressive.webp)

- **还不懂 再理解看看?**

![img](assets\ba3cde01c3cb1db02ce259f483d62b94b56c872d.png@942w_270h_progressive.webp)

- **总结**

linux在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令，

所以`>/dev/null 2>&1`的作用就是让**标准输出重定向**到`/dev/null`中（丢弃标准输出），然后错误输出由于重用了标准输出的描述符，所以**错误输出也被定向**到了`/dev/null`中，错误输出同样也被丢弃了。执行了这条命令之后，**该条shell命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中。**



## Linux的命令执行退出状态

- 在 Linux 系统中，每当命令执行完成后，系统都会返回一个退出状态。退出状态用于检查命令执行的结果（成功/失败），退出状态是一个数字。
- 若退出状态值为 0，表示命令运行成功；而退出状态值不为 0 时，则表示命令运行失败。**最后**一次执行的命令的退出状态值被保存在内置变量**`$?`**中，所以可以通过 **`echo`** 语句进行测试命令是否运行成功。
- POSIX 规定了以下几种退出状态和退出状态的含义。

| 状态值 | 含义                                               |
| -----: | -------------------------------------------------- |
|      0 | 表示运行成功，程序执行未遇到任何问题               |
|  1-125 | 表示运行失败，脚本命令、系统命令错误或参数传递错误 |
|    126 | 找到了该命令但无法执行                             |
|    127 | 未找到要运行的命令                                 |
|   >128 | 命令被系统强行结束                                 |

- 举例说明：

  - 如我们输入：**`cd /root`**，然后再输入：**`echo $?`**，结果为0，表示最后一次执行的命令运行成功。
  - 我们切换到一个不存在的目录：**`cd test`**，提示**文件/目录不存在**。输入：**`echo $?`**看看状态如何，结果为**1，表示最后一次执行的命令运行失败**。

- 输入命令：`yahah`，提示命令不存在 

- 输入：`echo $?` 看看状态如何，结果为 127，表示未找到要运行的命令

  ![19189112-7ec65f37d7d1908f](assets\19189112-7ec65f37d7d1908f.webp)

#### 其他

```ruby
$0：shell或shell脚本的名字
$*：以一对双引号给出参数列表
$@：将各个参数分别加双引号返回
$#：参数的个数
$_：代表上一个命令的最后一个参数
$$：代表所在命令的PID
$!：代表最后执行的后台命令的PID
$?：代表上一个命令执行后的退出状态
```

## shell 比较

##### 数值比较

```bash
-eq：表示等于，如：if [ $var1 -eq 100 ]
-ne：表示不等于，如：if [ $var1 -ne 100 ]
-gt：表示大于，如：if [ $var1 -gt 100 ]
-ge：表示大于等于，如：if [ $var1 -ge 100 ]
-lt：表示小于，如：if [ $var1 -lt 100 ]
-le：表示小于等于，如：if [ $var1 -le 100 ]
```

##### 字符串比较（也可用于数值比较)

```bash
==：表示相等，如：if [  $var1 == $var2 ]
!=：表示不相等，如： if [  $var1 != $var2 ]
=~：表示前边变量包含后边变量则为真，如：if [[  $var1 =~ $var2 ]]
注：本质上=~是正则匹配单层中括号不支持正则需要双层中括号
```

##### 字符串测试运算

```bash
-z 字符串：表示字符串的长度为零，如：if [ -z $var1 ]
-n 字符串：表示字符串的长度不为零，如：if [ -n $var1 ]
```

##### 文件测试运算

```bash
-e 文件名：表示如果文件存在则为真，如：if [ -e $var1 ]
-r 文件名：表示如果文件存在且可读则为真，如：if [ -r $var1 ]
-w 文件名：表示如果文件存在且可写则为真，如：if [ -z $var1 ]
-x 文件名：表示如果文件存在且可执行则为真，如：if [ -x $var1 ]
-s 文件名：表示如果文件存在且至少有一个字符则为真，如：if [ -s $var1 ]
-d 文件名：表示如果文件存在且为目录则为真，如：if [ -d $var1 ]
-f 文件名：表示如果文件存在且为普通文件则为真，如：if [ -f $var1 ]
-c 文件名：表示如果文件存在且为字符型特殊文件则为真，如：if [ -c $var1 ]
-b 文件名：表示如果文件存在且为块特殊文件则为真，如：if [ -b $var1 ]
```

##### 逻辑运算(与/或/非)

```ruby
-a或者&&：与运算，如：if [ $var1 == '' -a $var2 != '' ] 或 if [ $var1 == '' ] && [ $var2 != '' ]
-o或者||：或运算，如：if [ $var1 == '' -o $var2 != '' ]或if [ $var1 == '' ] || [ $var2 != '' ]
!：非运算，如：if ! [ $var1 == '' ]或if [ ! $var1 == '' ]
```



