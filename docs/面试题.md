面试题



# 1.

## CommonJs和Es Module的区别

### CommonJs

- CommonJs可以动态加载语句，代码发生在运行时
- CommonJs混合导出，还是一种语法，只不过不用声明前面对象而已，当我导出引用对象时之前的导出就被覆盖了
- CommonJs导出值是拷贝，可以修改导出的值，这在代码出错时，不好排查引起变量污染

### Es Module

- Es Module是静态的，不可以动态加载语句，只能声明在该文件的最顶部，代码发生在编译时
- Es Module混合导出，单个导出，默认导出，完全互不影响
- Es Module导出是引用值之前都存在映射关系，并且值都是可读的，不能修改


作者：蛙人
链接：https://juejin.cn/post/6938581764432461854
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





# 2

## 如何使用URLSearchParams

![img](https://images.xiaozhuanlan.com/photo/2019/0c12f63173f4432884f75f108e9d4e3d.png)

这两种方式就获得了链接参数对象。URLSearchParams支持以下方法：

**(1) has() 判断某一参数是否存在**

![img](https://images.xiaozhuanlan.com/photo/2019/fe232356174e58a85126fffd2b755cd2.png)

**(2) get() 获取参数的值**

![img](https://images.xiaozhuanlan.com/photo/2019/ca9ac982647e4896e5841eddc4ed7940.png)
这样的方式是不是比自己解析字符串省心很多呢？

**(3) getAll() 获取参数所有的值**

这个意思是在链接中同一个参数多次出现，getAll方法可以获得全部的值，返回一个数组。此时使用get方法只返回该参数首次出现时的值。举个例子就容易理解了：

![img](https://images.xiaozhuanlan.com/photo/2019/d781de4b76b0c84b287cd537131bcce4.png)

**(4) append() 添加参数**

这里的添加参数不是指向URL中添加参数，而是向URLSearchParams对象中添加参数。

![img](https://images.xiaozhuanlan.com/photo/2019/266e299b94910e61ada587c02edb8af0.png)

我们可以利用这个方法将URLSearchParams当做Map来使用，并且URLSearchParams提供了很多方法来方便的读取，写入，修改参数。

**(5) set() 修改参数**

用来修来URLSearchParams中某一参数的值。

![img](https://images.xiaozhuanlan.com/photo/2019/d2d041d4d11847fb5b8ca341d87f8ec5.png)

需要注意的是，如果修改的参数在链接中存在多个，set会全部修改并只保留一个。

>一个实现了 `URLSearchParams` 的对象可以直接用在 [`for...of`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of) 结构中，例如下面两行是相等的：

```
for (const [key, value] of mySearchParams) {}
for (const [key, value] of mySearchParams.entries()) {}
```

示例

```javascript
 let paramsStr = 'q=URLUtils.searchParams&topic=api&topic=api1'
    let searchParams = new URLSearchParams(paramsStr)

    for (let [key, value] of searchParams.entries()) {
      console.log(key, value) // q URLUtils.searchParams    topic api    topic api1
    }
    for(let item of searchParams){
      console.log(item) // ["q", "URLUtils.searchParams"] ["topic", "api"] ["topic", "api1"]
    }

    console.log(searchParams.has('topic') === true) // true
    console.log(searchParams.get('topic') === 'api') // true
    console.log(searchParams.get('topic')) // api
    console.log(searchParams.getAll('topic')) // ["api", "api1"]
    searchParams.append('topic', 'webdev') 
    console.log(searchParams.toString()) // q=URLUtils.searchParams&topic=api&topic=api1&topic=webdev
    searchParams.set('topic', 'more')    // q=URLUtils.searchParams&topic=api&topic=api1&topic=webdev
    console.log(searchParams.toString()) // q=URLUtils.searchParams&topic=more
    searchParams.delete('topic')
    console.log(searchParams.toString()) // q=URLUtils.searchParams
```



# 3

## sort

- `sort()`方法用于对数组的元素进行排序。
- `sort()`会修改原数组。

`sort()` 方法接受一个可选参数,用来规定排序顺序,必须是函数。

如果没有传递参数, `sort()` 方法默认把所有元素先转换为 `String` 再排序 ,根据 `ASCII` 码进行排序。

如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 **a** 和 **b**，其返回值如下：

- 若 `a` 小于 `b`，在排序后的数组中 `a` 应该出现在 `b` 之前，则返回一个小于 `0` 的值。
- 若 `a` 等于 `b`，则返回 `0`。
- 若 `a` 大于 `b`，则返回一个大于 `0` 的值。

有这样一个数组 `[10, 20, 1, 2]` 现在有如下需求

按从小到大排序。



```text
let arr = [10, 20, 1, 2];
arr.sort(function (x, y) {
    if (x < y) {
        return -1; // 不一定是-1 只要返回小于0的就意味着升序
    }
    if (x > y) {
        return 1; 
    }
    return 0;
});
console.log(arr);
```

按从大到小排序



```text
let arr = [10, 20, 1, 2];
arr.sort(function (x, y) {
    if (x < y) {
        return 1; // 不一定是 1 只要返回大于0的就意味着降序
    }
    if (x > y) {
        return -1;
    }
    return 0;
});
```



# 4

### 箭头函数

Es6中箭头函数是其中最有趣的特性，箭头函数是一种使用箭头`=>`定义函数的新语法，但是它与传统的`JavaScript`函数有些不同，具体看下面几点。

- 没有`this`、`super`、`arguments`
- 不能通过`new`关键字调用
- 没有原型`prototype`
- 不可以改变`this`指向
- 不支持重复的命名参数

> 箭头函数和传统函数一样都有一个name属性，这一点是不变的。


#### 箭头函数没有this

箭头函数的`this`值，取决于函数外部非箭头函数的`this`值，如果上一层还是箭头函数，那就继续往上找，如果找不到那么`this`就是`window`对象

```javascript
let person = {
    test: () => {
        console.log(this)
    },
    fn() {
        return () => {
            console.log(this)
        }
    }
}
person.test()  // window
person.fn()()  // person对象

```

上面example中，可以清楚的看到箭头没有`this`，那么它的`this`只会去找外层的非箭头函数的函数。

#### 箭头函数没有`arguments`对象

同样箭头函数也没有`arguments`对象，但是如果它外层还有一层非箭头函数的话，就会去找外层的函数的`arguments`对象， 如下

```javascript
let test1 = () => console.log(arguments)  // 执行该函数会抛出错误


function test2(a, b, c) {
    return () => {
        console.log(arguments) // [1, 2, 3]
    }
}
test2(1, 2, 3)()

```

上面example中，可以清楚的看到当前的箭头函数没有`arguments`对象，然而就去它的外层去找非箭头函数的函数。`注意：箭头函数找arguments对象只会找外层非箭头函数的函数，如果外层是一个非箭头函数的函数如果它也没有arguments对象也会中断返回，就不会在往外层去找了`。看下面例子

```scss
function test(a) {
    return function() {
        return () => {
            console.log(arguments) // []
        }
    }
}
test(1)()()

```

上面example中可以看到，里面的箭头函数往外层找非箭头函数的函数，然后不管外层这个函数有没有`arguments`对象都会返回。只有它是非箭头函数就可以，如果外层是箭头函数还会继续往外层找。

#### 箭头函数不能用`new`关键字声明

```javascript
let test = () => {}
new test() // 抛出错误，找不到constructor对象

```

#### 箭头函数没有原型`prototype`

切记，箭头函数没有原型，有可能面试官会问，`JavaScript`中所有的函数都有`prototype`属性吗

```javascript
let test = () => {}
test.prototype // undefined

```

#### 箭头函数不能改变`this`指向

```scss
let person = {}
let test = () => console.log(this)

test.bind(person)()
test.call(person)
test.apply(person)

```

上面example中，改变`this`指向的方法都不会抛出错误，但是都无效，都不能改变`this`指向。

#### 箭头函数不能重复命名参数

```javascript
let sum = (a, a) => {} // 抛出错误，参数不能重复
```



# 5

## 为什么vue3中根组件可以有多个根节点

vue2中只能有一个根标签，但是在vue3中根组件已经可以有多个根节点了

在vue2中只所以这么做是因为vdom是一颗单根树形结构，patch方法在遍历的时候从根节点开始遍历，它要求只有一个根节点，组件也会转换为一个vdom,自然满足这个要求

vue3中值所以可以有多个节点，是因为引入了Fragment的概念，这是一个抽象的节点，如果发现组件有多个根，就创建一个Fragment节点，把多个根节点作为它的children,将来path的时候，如果发现是一个Fragement节点，则直接遍历children创建或更新。






# 小技巧

### 随机ID

### 生成随机Id

有些情况下我们想要获取随机不重复的字符串，就可以使用如下方法

```javascript
Math.random().toString(36).slice(2)
```



### 快速将字符串转换为数组

不再使用字符串`split`方法，使用扩展运算符可以快速转换为数组。

```javascript
let str = "abcdefg"
console.log([...str]) // ["a", "b", "c", "d", "e", "f", "g"]
```

### 随机打乱数组顺序

有时我们场景有需要将一个数组顺序进行打乱。(原理 比较函数随机返回 <0 和 >0)

```javascript
let list = [1,2,'蛙人', 1, 34, 3, 12]
let res = list.sort(() => Math.random() - 0.5)
console.log(res)
```

### 判断地址是否有效

```javascript
function IsUrl(val) {
    try {
    	if (new URL(val)) {
    	    return true        
        }
    } catch(e) {
    	return false
    }
}
IsUrl("https://www.baidu.cn") // true
IsUrl("www.baidu.cn") // false
```

